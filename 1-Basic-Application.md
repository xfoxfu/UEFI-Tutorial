# 1 简单的 UEFI 应用程序

> **摘要**：本文将简单介绍 UEFI 的相关背景知识，随后提供一个绘制图形的 UEFI 应用程序。

## 计算机的启动

在「计算机组成原理」课程中，各位应该都编写过一个简单的 CPU，而这个 CPU 带有一段预先编写好的程序。在那时，我们的 CPU 只需要支持最简单的固定的外部设备，因此我们可以直接编写程序来满足这些外部设备的需要，并且把程序固化到 CPU 的 ROM 中。但是，现实中的计算机（指 IBM PC）具有多种不同的设备，而 CPU 需要适应多种外部设备和执行环境，因此人们发明了 DDR、PCI、PS/2、USB 等多种不同的通信协议，从而构建了 CPU 和外部设备通信的标准；同时，计算机通过引入 BIOS 这个中间层来实现设备的初始化。

在现在的计算机中，主板芯片组（如 AMD B450）会带有一块小型的 ROM，其中存放了初始化计算机的各种设备的代码。主板制造商通过连接 CPU 的地址线，使得芯片组上的程序的入口地址和 CPU 通电后的默认指令地址相同。这样，计算机在启动后就会执行这段代码，来检测内存、初始化主板芯片组、检测设备，而这段代码就被称为 BIOS。

在完成了基本的初始化过程后，BIOS 将加载磁盘扇区 0 的内容，放置在 `0x7C00` 地址，然后跳转到该地址执行引导程序。引导程序将完成探测内存布局、加载操作系统内核等工作，并最终进入到操作系统内核中。

这里叙述的引导过程有所简化，没有讨论在没有内存的情况下如何完成内存的初始化等内容。知乎用户[老狼](https://www.zhihu.com/people/mikewolfwoo)有一系列文章叙述了计算器 BIOS 和 UEFI 相关的知识，包括 Cache As RAM、可信启动等，各位读者可以简单参考作为补充。

## BIOS 与 UEFI

为了有效地让操作系统（引导程序）能够知晓系统的情况（如内存布局，也就是内存地址的分布情况），BIOS 向操作系统提供了一系列[系统调用](https://wiki.osdev.org/BIOS)，这些调用通过中断触发。当触发中断后，BIOS 之前在 CPU 中注册的中断处理程序就会被执行，从而执行对应的功能。

BIOS 本身没有任何的规范定义，而是各个厂家在漫长的历史实践中，建立了一系列约定，使得各个不同厂家生产的计算机能够获得相似的表现。但是，因为缺乏规范，这样的历史实践并不能保证在所有的计算机上表现一致。

此外，在 BIOS 启动的引导程序运行时，系统的内存布局存在一个特殊的约定，从而使得引导程序不必获得完整的内存布局就可以执行一些简单的工作。这段内存的大小为 1MB，对于较大的引导程序来说有些紧张。同时，一个扇区的大小只有 512B，这也限制了引导程序的代码大小。因此，现在的引导扇区程序（如 Grub）往往采用两阶段引导的模式，第一阶段称为 Boot，放置在引导扇区中；而第二阶段称为 Loader，放置在磁盘的一个特殊区域；从而突破 BIOS 的代码和内存限制。

最后，BIOS 基于中断的函数调用产生了两个问题。其一是，中断调用的效率较低，导致计算机启动缓慢。其二是，引导程序和操作系统为了实现高级功能，往往会注册自己的中断处理程序，这可能和 BIOS 发生冲突。

为了更好地解决这一问题，Intel 联合 PC 厂商建立了 UEFI 标准，这是下一代的计算机固件的接口定义。有了 UEFI，操作系统开发人员能够更好地去实现操作系统的功能，编写更加复杂的引导程序，甚至可以在引导程序或固件管理界面访问网络、显卡等高级功能。

## UEFI 程序

在 BIOS 引导中，我们将程序编译为裸二进制，放置在引导扇区中，这样的操作非常复杂，而且不方便调试。对于 UEFI 引导，我们只需要将程序编译为 EFI 格式的可执行文件，放置在磁盘的 EFI 分区的特定位置，即可令 UEFI 加载我们的可执行文件。

因此，编写 UEFI 应用程序和编写一般的应用程序的差别不是很大，我们同样会运用以前学习过的编译、链接等方法生成二进制文件。只是，这个二进制文件的格式和我们一般的在操作系统上运行的格式不同，因此我们需要添加一些编译参数。当然，如果利用一些现有的工具方法，那么这部分工作也有前人帮助我们完成了。

对于传统的 C/C++ 应用程序，我们会编写

```cpp
int main(int argc, char** argv);
```

而对于 EFI 应用程序来说，程序的入口稍有不同。它的入口定义为

```cpp
EFI_STATUS efi_main(EFI_HANDLE ImageHandle, EFI_SYSTEM_TABLE *SystemTable)
```

其中，`SystemTable` 是我们访问 UEFI 功能的核心，其中包含了一些数据（如系统固件的名称和版本）以及一些函数指针，这些函数指针将提供众多的 UEFI 功能，以及和其它 UEFI 应用程序交互的方法。是的，UEFI 中，各种设备的驱动也作为 UEFI 应用程序提供。

> **提示**：从这里可以看到，UEFI 应用程序和普通的运行在操作系统上的应用程序是类似的，而且其同样通过入口点的参数来传递系统的相关信息。

常见的编写 C/C++ UEFI 应用程序的框架包括

- [EDK Ⅱ](https://github.com/tianocore/edk2)
- [gnu-efi](https://sourceforge.net/projects/gnu-efi)
- [POSIX-UEFI](https://gitlab.com/bztsrc/posix-uefi)

这些框架提供了标准的构建流程、类型声明以及辅助函数，从而使得我们可以方便地编写 UEFI 应用程序。笔者这里推荐使用 POSIX-UEFI 库，因为其和传统的 libc 提供了类似的函数，并且提供了预置的 Makefile，构建起来非常方便。

> **提示**：需要注意的是，因为 UEFI 运行时没有操作系统，因此也就没有 libc，所以我们不能直接使用 `printf` 一类的函数。这也是我们需要使用开发框架的原因。

对于 Rust 语言，则推荐使用 [uefi](https://lib.rs/crates/uefi) 库。

<!-- TODO: 应用程序实例 -->

<!-- ## 附录：关于 arm 指令集 -->
